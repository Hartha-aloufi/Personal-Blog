---
title: بروتوكول لتحكم بالنقل TCP 
date: '2021-12-23'
tags: ['شبكات', 'TCP', 'بروتوكول']
draft: false
summary: 'نظرة تفصيلية في بروتوكول التحكم بالنقل TCP وماذا يمكن للمطور فعله لتحسين اداءه'
---

# بروتوكول التحكم بالنقل TCP





البروتوكول هو مجوعة من القواعد المتفق عليها والتي تحدد كيفية تبادل البيانات بين الأجهزة على الشبكة بغض النظر عن الاختلافات بينها.

 هذه القواعد تشمل كيفية بدء التبادل وشكل البيانات وتنسيقها وحجمها وأيضاً كيفية التعامل مع الحالات الكثيرة قبل وبعد وأثناء التبادل كالتأكد من وصولها وأمانها وما العمل في حال فقدان جزء منها وغير ذلك.   

لكن ماذا عن صديقنا لهذا اليوم، بروتوكول التحكم بالنقل TCP أو (Transmission Control Protocol): هو بروتوكول يوفر  اتصالاً موثوقاً لنقل البيانات بين جهازين على الشبكة. أي أنه يضمن وصول البيانات من المرسل الى المستقبل، ويضمن أيضاً ايصالها بالترتيب الصحيح. وهو يفعل هذا كله بالاعتماد على قناة اتصال غير موثوقة يوفرها بروتوكول آخر هو بروتوكول الشابكة (Internet Protocol - IP).

يأخذ بروتوكول التحكم بالنقل على عاتقه الكثير من تعقيدات التواصل في الشبكة ويخفيها عن تطبيقاتنا: كإعادة ارسال البيانات الضائعة والتحكم بالاحتقان(Congestion control) وتجنبه وسلامة البيانات وغير ذلك. بروتوكول التحكم بالنقل حُسٍّن وطُوِّرَ بشكل أساسي من أجل الدقة وليس السرعة، وهذا يعرضنا لمجموعة من التحديات عند تحسين أداء الويب.

لم تحدد معايير الـ HTTP بروتوكول التحكم بالنقل TCP كبروتوكول النقل الوحيد ولا تلزم به، فيمكننا استخدام الـ UDP أو أي بروتوكول آخر لإيصال الـ HTTP، لكن عملياً، جميع حركات الـ HTTP عبر الشابكة تتم من خلال الـ TCP وذلك للمزايا الرائعة التي يقدمها.



### التصافح الثلاثي (Three Way Handshaking)

وهي عملية لتهيئة الاتصال واعداده قبل بدء نقل البيانات, فجميع الاتصالات التي تتم باستخدام الـ TCP تبدأ بتصافح ثلاثي، حيث يجب على طرفي الاتصال -الخادم والعميل- الاتفاق على مجموعة من الأرقام والمتغيرات الضرورية والتي تخص الاتصال قبل بدئه.



##### SYN

يقوم العميل باختيار رقم متسلسل "x" بشكل عشوائي، ثم يرسل حزمة SYN من كلمة (Syncronization) الى الخادم، ويمكن أيضاً أن تضمن الحزمة خيارات متغيرات أٌخرى تخص الـ TCP.



##### SYN ACK

يقوم الخادم بزيادة "x" ك ACK من كلمة (Acknowledgment) والتي تعني اشعار استلام، ثم يختار رقماً متسلسلاً خاص به "Y"، ويضيف ما يريد من خيارات ومتغيرات تخص الـ TCP ثم يرسل الرد.



##### ACK

يقوم العميل بزيادة الرقمين المتسلسلين "x" و "y" ثم ينهي التصافح الثلاثي بإرسال آخِر إشعار استلام الى الخادم.



وحين تكتمل عملية التصافح الثلاثي، يمكن للخادم والعميل بدء تبادل البيانات. فيستطيع العميل ارسال حزمة بياناتٍ مباشرةً بعد ارسال الإشعارـ ويجب على الخادم الانتظار حتى يستلم حزمة الإشعار قبل أن يتمكن من ارسال أي بيانات للعميل. وهذه التهيئة تتم قبل كل اتصال TCP، وهذا يفرض تكلفة حتمية عند بدء أي اتصال تؤثر على أداء جميع التطبيقات التي تستخدم بروتوكول التحكم بالنقل TCP. 

على سبيل المثال، لو كان العميل في مدينة نيويورك والخادم في مدينة لندن، وقمنا ببدء اتصال TCP جديد باستخدام خط الياف ضوئيّة، فستستغرق عملية التصافح الثلاثي 58 جزء من الثانية، وهنا لم يلعب عرض النطاق أي دور، فالمحدد هنا هو زمن الوصول بين الخادم والعميل والذي يمثل أغلبه زمن الارسال بين نيويورك ولندن.

التأخير المفروض من قبل عملية التصافح الثلاثي تجعل من عملية انشاء اتصال TCP جديد أمراً مكلفاً وتعتبر أحد الأسباب الرئيسية في كون ميزة إعادة استخدام الاتصال تحسين حاسماً في جميع التطبيقات التي تعمل باستخدام بروتوكول التحكم بالنقل TCP.

### التحكم بالتدفق (Flow Control)

التحكم بالتدفق هي آلية لمنع المرسل من إغراق المستقبل بكمية بيانات هو غير قادر على مجاراته فيها ومعالجتها. فقد يكون المستقبل مشغولاً أو أنه قد خصص مساحة  بفر (buffer) ثابتة. ولمعالجة هذا، يقوم كلا طرفي الاتصال بالإعلان عن نافذة الاستقبال الخاصة بهما (Recive window) ويشار اليها ب rwnd والتي تمثل المساحة المتاحة من البفر لحفظ البيانات فيها مؤقتاً. عندما يتم تجهيز الاتصال، يقوم كلا الطرفين بتهيئة حجم نافذة الاستقبال باستخدام القيم الافتراضية لنظام التشغيل الخاص بكل منهما.

وفي حال عدم قدرة أحد الطرفين على الاستمرار على نفس النسق، يقوم بتقليل حجم النافذة ويعلن عن ذلك للطرف الآخر. فإذا وصل حجم النافذة الى الصفر، فذلك يعني أن المستقبل لا يمكنه استقبال المزيد وعلى المرسل الانتظار حتى افراغ البفر.

##### توسيع نافذة الاستقبال

تم تخصيص 16-بت لنافذة الاستقبال في مواصفات الـ TCP، وذلك يعني أن الحد الأعلى هو 65535-بايت، ولكن لاحقاً، غدى هذا الحد غير كافٍ للحصول على الأداء الأفضل، خاصةً في الشبكات التي تمتلك عرض نطاق عالٍ. ولحل هذه المشكلة تم طرح ميزة توسيع نافذة (window scaling) والتي تسمح لنا بزيادة الحد الأعلى للنافذة 1-جيجا. هذه الميزة مفعّلة افتراضياً على جميع المنصات الرئيسية. وهي نقطة بداية جدية عند البحث عن السبب وراء قصور الشبكة عن استغلال كامل عرض النطاق.

### البداية ببطء (Slow Start) 

على الرغم من أن التحكم بالتدفق ناجح في منع المرسل من إغراق المستقبل بكمية من البيانات, الا أنه لا يمنع أيًً من الطرفين من اغراق الشبكة التي تربطهما. وذلك لعدم معرفتهما بكم النطاق المتاح عند بدء اتصالٍ جديد. ولذلك فإننا بحاجة الى آلية لتخمين المتاح منه  وأيضاً لضبط سرعة الاتصال وجعله يتكييف مع حالة الشبكة التي تتغير باستمرار. 

ولنظرب مثالاً على ذلك, تخيَّل أنك متصل بشبكة المنزل وتشاهد أحد المرئيات من على أحد الخوادم والذي يسعى الى إشباع كامل المتاح من نطاق التحميل لديك ليوصل لك أفضل جودةٍ للمرئية, ثم ظهر مستخدم آخر على نفس شبكتك وبدأ بتحميل ملف كبير. هنا فجأةً قل المتاح من نطاق التحميل لاتصالك بدرجة كبيرة, فيجب على الخادم فوراً أن يتكييف مع هذا التغير, عدا ذلك, اذا استمر بنفس المستوى ستتكوم البيانات في احدى نقاط الشبكة ثم تلقى. وهذا استخدام غير ناجع للشبكة.



الطريقة الوحيدة لتخمين المتاح من النطاق هي بقياسه, وذلك عند تبادل البيانات! هذا بالتحديد ما تفعله خوارزمية "البداية ببطء". حيث يقوم الخادم بتهيئة متغيراً لحجم نافذة الاحتقان باسم (cwnd) لكل اتصال TCP بقيمة افتراضية يأخذها من نظام التشغيل, وهي (initcwnd) على نظام التشغيل لينكس. 



##### *نافذة الاحتقان*:

هو حدٌ يتم ضبطه من جهة المرسل يحدد كمية البيانات البينية -التي أُرسلت ولم يتم تأكيد استلامها بعد- المسموح بها قبل وصول اشعار استلام (Acknowledgment - ACK) من المستقبل.



لاحقاً, تم إضافة تعديل وهو: كم البيانات البينية المسموح بها هي القيمة الأصغر بين المتغيرين cwnd و rwnd. وهذا يطرح سؤالاً مهماً وهو كيف يحدد المرسل والمستقبل أفضل قيمٍ لهذين المتغيرين؟ 

الحل هو أن نبدأ ببطءٍ بقيمٍ صغيرة ثم نقوم بزيادتها تدريجياً مع وصول إشعارات الاستلام. في الأصل كانت القيمة الابتدائية 1 ثم لاحقاً حُدثت الى 4, ومؤخراً في عام 2013 تم رفعها الى 10.

وذلك يعني أن المرسل يستطيع ارسال أربعة اقطاع بيانية (TCP Segment) ثم بعدها عليه التوقف الى حين وصول تأكيد الاستلام. وعند استلام التأكيد تقوم خوارزمية "البداية ببطء" بزيادة قيمة متغير نافذة الاحتقان cwnd بمقدار 1 لكل تأكيد استلام. ولاحظ أن تأكيد الاستلام يكون لكل حزمة وليس لكل قطع, وهذا يعني أن لدينا نمواً أُسياً لحجم نافذة الاحتقان. 



************* صورة



معرفة تفاصيل هذه الخوارزمية مهم جداً, وذلك لأنها تطبق على جميع الاتصالات المعتمدة على بروتوكول النقل TCP والذي هو عماد بروتوكول الـ HTTP والذي هو بدوره عِمادُ تطبيقات الويب. وهذا يقودنا لاستنتاج مهم, وهو أننا لا نستطيع استخدام كامل قدرة الشبكة مباشرةً, بل نحتاج لبعض الوقت حتى نصل الى القيمة الأفضل لمتغير نافذة الاحتقان cwnd. هذا الأمر لا يعد مشكلة للاتصالات الطويلة عند نقل بيانات كبيرة كتحميل الملفات وبث المرئيات, حيث أن عدد الدورات (Round trip) اللازمة للوصول الى القيمة المثلى لا تعد شيءً نسبةً الى عدد دورات الاتصال كاملةً. و من جهة أُخرى يعد مشكلة كبيرة بالنسبة للاتصالات القصيرة والسريعة والتي هي عملياً أغلب اتصالات الـ HTTP في تطبيقات الويب, فينتهي الاتصال قبل أن نصل الى القيمة المثلى لنافذة الاحتقان. وهذا يحد من كفاءة استخدامنا لقدرات الشبكة وبطء أداء تطبيقاتنا.



#### إعادة تهيئة البداية ببطء (Slow-Start Restart SSR)

هي ميزة مطبقة في برتوكول الـ TCP تقوم بإعادة تهيئة قيمة نافذة الاحتقان cwnd للاتصالات الخاملة بعدة مدة محددة. المنطق وراء هذا الميزة بسيط, وهو أن حال الشبكة يمكن أن يكون قد تغير اثناء خمول الاتصال, ولتفادي الاتقان سنعيد تهيئة النافذة بقيمتها الافتراضية.

من غير المفاجئ أن تعلم أن هذه الميزة لديها تأثير سيئ وقوي على اتصالات الـ TCP الطويلة مثل الـ HTTP Keep-alive. ولهذا ينصح بإيقاف هذه الميزة على الخوادم. يمكن الوصول الى إعدادات الـ SSR وتعديلها على نظام اللينكس من خلال هذين الأمرين:

```
$> sysctl net.ipv4.tcp_slow_start_after_idle

$> sysctl -w net.ipv4.tcp_slow_start_after_idle=0
```



### تلافي الاحتقان (Congestion avoidance)

من المهم جداً معرفة أن الـ TCP صمم بطريقة يستفيد فيهما من ضياع الحزم (Packet loss) باعتبارها تغذيةً راجعة (اثراءً) يستخدمها لتحسين الأداء. فالافتراض الضمني هو أنه عند حصول ضياعٍ للحزم فذلك يعني وجود خطٍ أو موجهٍ محتقن في مكانٍ ما على الشبكة أُجبر على اهمال بعض الحزم. ويجب علينا أن نتكيف ونعالج هذا من خلال تعديل حجم النافذة لتلافي الاحتقان وضياع مزيد من الحزم. 



##### خوارزمية تخفيض المعدل النسبي (Proportional Rate Reduction)

خوارزمية طورت من طرف شركة جوجل لتطبق مفوهم تلافي الاحتقان. في الأساس كان الـ TCP يعتمد على خوارزمية الانقاص المضاعف والزيادة التدريجية (AIMD) والتي تقوم بانقاص النافذة الى النصف عند ضياع الحزم, ثم تزيدتها تدريجيا بمقدار ثابت, لكن أداء هذه الخوارزمية لم يكن كما يجب. خوارزمية PRR طورت بهدف تحسين سرعة التكيف والتعافي بعد ضياع الحزم. ووفقاً للتجارب التي اجربتها شركة جوجل, فانها تقلل زمن الوصول بعد ضياع زمن الحزم بنسبة 3-10%.

خوارزمية تخفيض المعدل النسبي (PRR) هي الآن خوارزمية تلافي الاحتقان الافتراضية في نواة لينكس 3.2+, وهذا سبب قوي لنحرص دائما على تحديث الخوادم.



### Head of line blocking

 يمتلك بروتوكول التحكم بالنقل الـ TCP مجموعة من المزايا مثل التحكم بالتدفق والتحكم بالاحتقان وتلافيه والايصال بالترتيب واعادة ارسال الحزم المفقودة, كل هذه الميزات مجتمعة هي ما تجعل من الـ TCP البروتوكول المفضل لأغلب التطبيقات, ولكن ليس لجميعها. فمثلاً تطبيقات المحادثات الصوتية لا تحتاج الى ميزة اعادة الارسال والايصال بالترتيب وذلك لأن هذه المزايا تكون على حساب السرعة والتي هي في مثل هذه التطبيقات العامل الحاسم والأهم, لذا فهناك بروتوكولات أُخرى للنقل مثل الـ UDP والذي يستخدم في هكذا تطبيقات.



ولنعمق الفهم هنا, دعنا نشرح آلية اعادة الارسال والايصال بالترتيب:

يقوم برتوكول الـ TCP بإعطاء كلَ حُزمةٍ رقماً تسلسلياً عند إرسالها. وفي حال حصل فقدانٌ لأحد الحزم في نقطة ما من نقاط خط الاتصال, يستطيع المستقبل إدراك ذلك بالنظر الى أرقام الحزم التي استقبلها! فينتظر الحزمة المفقودة حتى يتم اعادة ارسالها ويضع باقي الحزم الخارجة عن الترتيب في بفر(TCP Buffer). وقد تكلمنا سابقاً عن تأكيّد الاستلام الذي يرسله المستقبل للمرسل عند استلامه لحزمةٍ ما. هذا التأكيد تيضمن رقم الحزمة المُستلمة, وبذلك يدرك المرسل أيضاً فقدان تلك الحزمة في حال لم يستلم تأكيداً لها لمدة محددة فيعيد إرسالها. ويستمر المستقبل في حجز الحزم الخارجة عن الترتيب حتى يستلم الحزمة المفقودة.



يتم هذا كله على مستوى الـ TCP في طبقة النقل (Transport Layer) أي خارج نطاق تطبيقاتنا والتي لا تعلم عن شيءً عن حال البيانات, فاذا فقدت احدى الحزم لا تستطيع تطبيقاتنا الوصول الى البيانات التي في البفر أو حتى معرفة ذلك. بل عليها الانتظار حتى تصل الحزمة المفقودة ويتم تفريغ البفر ثم تصلها البيانت كاملة. وهذا بالنسبة الها ليس سوى تاخر في الوصول, وهذا التأثير هو ما يدعى ب Head of line blocking.



### مطور الويب والـ TCP

الزبدة هنا, ماذا يستطيع مطور الويب عمله لتحسين أداء بروتوكول التحكم بالنقل؟

1. تأكد من أنك لا ترسل أي بيانات لا تحتاجها. فعدم ارسالك للبيانات هو بالتاكيد اسرع ارساله :smile:.

2. قلل مسافة الارسال, وذلك بجعل الخوادم اقرب الى المستخدمين من خلال توزيع الخوادم جغرافياً حول العالم. بالستخدام الـ CDN على سبيل المثال.

3. اعادة استخدام اتصالات الـ TCP متى أمكن: TCP Keep Alive

4. ضبط الخوادم:

   1. تحديث النواة الى آخر اصدار.

   2. تأكد من أن قيمة نافذة الاحتقان cwnd تساوي 10.

   3. تاكد من أن ميزة توسيع النافذة (Window Scalling) فعالة.

   4. الغِ تفعيل ميزة اعادة تهيئة البداية ببطء (Slow Start Restart).

   5. فعل ميزة Fast Open إن أمكن.

   6. تاكد من ضغط البيانات قبل ارسالها.

      







​	





 

 